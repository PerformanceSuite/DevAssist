/**
 * Claude Configuration Generator for DevAssist v3.0
 * Generates optimized claude.md files for projects
 */

import { promises as fs } from 'fs';
import path from 'path';

export class ClaudeConfigGenerator {
  constructor() {
    this.sections = [];
  }

  /**
   * Generate complete claude.md file
   */
  async generateClaudeMD(projectPath, profile, agents) {
    const content = [];

    // Header
    content.push('# Claude Code Configuration\n');
    content.push(`Generated by DevAssist v3.0 on ${new Date().toISOString()}\n`);
    content.push('---\n');

    // Project overview
    content.push(await this.generateProjectOverview(profile));

    // Architecture section
    content.push(await this.generateArchitectureSection(profile));

    // Agents section
    content.push(await this.generateAgentsSection(agents));

    // Technology stack
    content.push(await this.generateTechnologySection(profile));

    // Standards and practices
    content.push(await this.generateStandardsSection(profile));

    // Security and compliance
    if (profile.special.security || profile.special.compliance) {
      content.push(await this.generateSecuritySection(profile));
    }

    // Special requirements
    if (profile.custom.oidc_wif || profile.custom.private_only || profile.custom.tokenization) {
      content.push(await this.generateSpecialRequirements(profile));
    }

    // Workflows
    content.push(await this.generateWorkflowsSection(profile));

    // Commands
    content.push(await this.generateCommandsSection(profile));

    // Save the file
    const claudePath = path.join(projectPath, '.claude', 'claude.md');
    await fs.mkdir(path.dirname(claudePath), { recursive: true });
    await fs.writeFile(claudePath, content.join('\n'), 'utf8');

    // Also save to root if no existing claude.md
    const rootClaudePath = path.join(projectPath, 'CLAUDE.md');
    if (!await this.fileExists(rootClaudePath)) {
      await fs.writeFile(rootClaudePath, content.join('\n'), 'utf8');
    }

    return claudePath;
  }

  /**
   * Generate project overview section
   */
  async generateProjectOverview(profile) {
    const section = [];

    section.push('## Project Overview\n');
    section.push(`**Name:** ${profile.name}`);
    section.push(`**Type:** ${profile.type.join(', ')}`);
    section.push(`**Complexity:** ${profile.complexity.level} (Score: ${profile.complexity.score}/100)`);
    section.push(`**Architecture:** ${profile.patterns.architecture}\n`);

    if (profile.structure.hasMonorepo) {
      section.push('**Structure:** Monorepo');
      if (profile.structure.hasWorkspaces) {
        section.push('**Workspaces:** Enabled');
      }
    }

    if (profile.structure.entryPoints.length > 0) {
      section.push(`**Entry Points:** ${profile.structure.entryPoints.join(', ')}`);
    }

    section.push('');

    return section.join('\n');
  }

  /**
   * Generate architecture section
   */
  async generateArchitectureSection(profile) {
    const section = [];

    section.push('## Architecture\n');
    section.push('### Core Architecture');
    section.push(`- **Style:** ${profile.patterns.architecture}`);
    section.push(`- **Design Patterns:** ${profile.patterns.design.join(', ')}`);
    section.push(`- **API Patterns:** ${profile.patterns.api.join(', ')}\n`);

    if (profile.patterns.auth && profile.patterns.auth.length > 0) {
      section.push('### Authentication & Authorization');
      profile.patterns.auth.forEach(method => {
        section.push(`- ${method}`);
      });
      section.push('');
    }

    if (profile.custom.deployment) {
      section.push('### Deployment Strategy');
      section.push(`- **Method:** ${profile.custom.deployment}`);
      if (profile.stack.cloud) {
        section.push(`- **Cloud Provider:** ${profile.stack.cloud}`);
      }
      if (profile.custom.region) {
        section.push(`- **Region:** ${profile.custom.region}`);
      }
      section.push('');
    }

    return section.join('\n');
  }

  /**
   * Generate agents section
   */
  async generateAgentsSection(agents) {
    const section = [];

    section.push('## Intelligent Agents\n');
    section.push(`This project has ${agents.length} specialized agents configured:\n`);

    // Group agents by category
    const categories = {
      architecture: [],
      development: [],
      operations: [],
      quality: [],
      specialized: []
    };

    agents.forEach(agent => {
      if (agent.name.includes('architect')) {
        categories.architecture.push(agent);
      } else if (agent.name.includes('dev') || agent.name.includes('engineer')) {
        categories.development.push(agent);
      } else if (agent.name.includes('ops') || agent.name.includes('deploy')) {
        categories.operations.push(agent);
      } else if (agent.name.includes('test') || agent.name.includes('review')) {
        categories.quality.push(agent);
      } else {
        categories.specialized.push(agent);
      }
    });

    // Write each category
    for (const [category, categoryAgents] of Object.entries(categories)) {
      if (categoryAgents.length > 0) {
        section.push(`### ${this.capitalize(category)} Agents\n`);
        categoryAgents.forEach(agent => {
          section.push(`- **${agent.name}** [${agent.model}]`);
          section.push(`  ${agent.description}`);
        });
        section.push('');
      }
    }

    section.push('### Agent Activation\n');
    section.push('Agents can be activated through:');
    section.push('- Direct invocation using agent commands');
    section.push('- Automatic trigger based on context');
    section.push('- Multi-agent workflow execution');
    section.push('- Slash command shortcuts\n');

    return section.join('\n');
  }

  /**
   * Generate technology section
   */
  async generateTechnologySection(profile) {
    const section = [];

    section.push('## Technology Stack\n');

    if (profile.stack.languages.length > 0) {
      section.push('### Languages');
      profile.stack.languages.forEach(lang => {
        section.push(`- ${this.capitalize(lang)}`);
      });
      section.push('');
    }

    if (profile.stack.frameworks.length > 0) {
      section.push('### Frameworks');
      profile.stack.frameworks.forEach(framework => {
        section.push(`- ${this.capitalize(framework)}`);
      });
      section.push('');
    }

    if (profile.stack.databases.length > 0) {
      section.push('### Databases');
      profile.stack.databases.forEach(db => {
        section.push(`- ${this.capitalize(db)}`);
      });
      section.push('');
    }

    if (profile.stack.tools.length > 0) {
      section.push('### Development Tools');
      profile.stack.tools.forEach(tool => {
        section.push(`- ${this.capitalize(tool)}`);
      });
      section.push('');
    }

    if (profile.stack.testing.length > 0) {
      section.push('### Testing Frameworks');
      profile.stack.testing.forEach(test => {
        section.push(`- ${this.capitalize(test)}`);
      });
      section.push('');
    }

    if (profile.stack.ci && profile.stack.ci.length > 0) {
      section.push('### CI/CD Systems');
      profile.stack.ci.forEach(ci => {
        section.push(`- ${this.capitalize(ci)}`);
      });
      section.push('');
    }

    return section.join('\n');
  }

  /**
   * Generate standards section
   */
  async generateStandardsSection(profile) {
    const section = [];

    section.push('## Standards & Best Practices\n');

    section.push('### Coding Standards');
    section.push('- Follow language-specific conventions');
    section.push('- Maintain consistent code style');
    section.push('- Write self-documenting code');
    section.push('- Use meaningful variable and function names');
    section.push('- Keep functions small and focused\n');

    section.push('### Testing Requirements');
    section.push(`- Minimum test coverage: ${profile.complexity.level === 'enterprise' ? '80%' : '70%'}`);
    section.push('- Write unit tests for all business logic');
    section.push('- Include integration tests for APIs');
    section.push('- Implement E2E tests for critical paths\n');

    section.push('### Documentation');
    section.push('- Document all public APIs');
    section.push('- Maintain up-to-date README files');
    section.push('- Include inline comments for complex logic');
    section.push('- Generate API documentation automatically\n');

    section.push('### Version Control');
    section.push('- Use descriptive commit messages');
    section.push('- Follow branching strategy (Git Flow/GitHub Flow)');
    section.push('- Create meaningful PR descriptions');
    section.push('- Review all code before merging\n');

    return section.join('\n');
  }

  /**
   * Generate security section
   */
  async generateSecuritySection(profile) {
    const section = [];

    section.push('## Security & Compliance\n');

    if (profile.special.security && profile.special.security.length > 0) {
      section.push('### Security Requirements');
      profile.special.security.forEach(req => {
        section.push(`- ${this.formatSecurityRequirement(req)}`);
      });
      section.push('');
    }

    if (profile.special.compliance && profile.special.compliance.length > 0) {
      section.push('### Compliance Requirements');
      profile.special.compliance.forEach(compliance => {
        section.push(`- **${compliance}**: Full compliance required`);
      });
      section.push('');
    }

    section.push('### Security Best Practices');
    section.push('- Never commit secrets or credentials');
    section.push('- Use environment variables for configuration');
    section.push('- Implement proper authentication and authorization');
    section.push('- Encrypt sensitive data at rest and in transit');
    section.push('- Regular security audits and vulnerability scanning');
    section.push('- Follow OWASP Top 10 guidelines\n');

    return section.join('\n');
  }

  /**
   * Generate special requirements section
   */
  async generateSpecialRequirements(profile) {
    const section = [];

    section.push('## Special Requirements\n');

    if (profile.custom.oidc_wif) {
      section.push('### OIDC/Workload Identity Federation');
      section.push('- **Authentication:** OIDC tokens only, no service account keys');
      section.push('- **Authorization:** Workload Identity Federation for resource access');
      section.push('- **Token Management:** Automatic refresh and validation');
      section.push('- **Security:** Zero-trust model with minimal permissions\n');
    }

    if (profile.custom.private_only) {
      section.push('### Private-Only Services');
      section.push('- **Access:** All services must be private (no public endpoints)');
      section.push('- **Networking:** VPC-only communication');
      section.push('- **External Access:** VPN or private connectivity required');
      section.push('- **Monitoring:** Alert on any public exposure attempts\n');
    }

    if (profile.custom.tokenization) {
      section.push('### Real-World Asset Tokenization');
      section.push('- **Compliance:** Full regulatory compliance for tokenized assets');
      section.push('- **KYC/AML:** Complete identity verification required');
      section.push('- **Smart Contracts:** Audited and secure token contracts');
      section.push('- **Transfer Logic:** Implement regulatory transfer restrictions\n');
    }

    if (profile.special.blockchain) {
      section.push('### Blockchain Integration');
      section.push('- **Smart Contracts:** Secure and audited contracts');
      section.push('- **Gas Optimization:** Minimize transaction costs');
      section.push('- **Security:** Follow best practices for Web3');
      section.push('- **Testing:** Comprehensive test coverage including mainnet forks\n');
    }

    if (profile.special.ai) {
      section.push('### AI/ML Components');
      section.push('- **Model Management:** Version control for models');
      section.push('- **Data Privacy:** Ensure user data protection');
      section.push('- **Performance:** Optimize inference latency');
      section.push('- **Monitoring:** Track model drift and performance\n');
    }

    return section.join('\n');
  }

  /**
   * Generate workflows section
   */
  async generateWorkflowsSection(profile) {
    const section = [];

    section.push('## Multi-Agent Workflows\n');

    section.push('### Development Workflow');
    section.push('1. **Planning:** Architecture agents design the solution');
    section.push('2. **Implementation:** Development agents write code');
    section.push('3. **Testing:** Test agents validate functionality');
    section.push('4. **Review:** Review agents ensure quality');
    section.push('5. **Deployment:** DevOps agents handle deployment\n');

    section.push('### Deployment Pipeline');
    section.push('1. **Pre-checks:** Security and compliance validation');
    section.push('2. **Build:** Create optimized artifacts');
    section.push('3. **Deploy:** Push to target environment');
    section.push('4. **Verify:** Post-deployment validation');
    section.push('5. **Monitor:** Continuous monitoring setup\n');

    if (profile.special.compliance) {
      section.push('### Compliance Workflow');
      section.push('1. **Assessment:** Evaluate compliance requirements');
      section.push('2. **Implementation:** Apply necessary controls');
      section.push('3. **Validation:** Verify compliance');
      section.push('4. **Documentation:** Generate compliance reports');
      section.push('5. **Monitoring:** Continuous compliance checking\n');
    }

    return section.join('\n');
  }

  /**
   * Generate commands section
   */
  async generateCommandsSection(profile) {
    const section = [];

    section.push('## Slash Commands\n');
    section.push('### Core Commands');
    section.push('- `/analyze` - Analyze codebase and generate insights');
    section.push('- `/deploy` - Deploy to configured environment');
    section.push('- `/test` - Run comprehensive test suite');
    section.push('- `/review` - Trigger code review workflow');
    section.push('- `/optimize` - Run performance optimization\n');

    if (profile.stack.cloud === 'gcp') {
      section.push('### GCP Commands');
      section.push('- `/gcp-deploy` - Deploy to Google Cloud Platform');
      section.push('- `/gcp-logs` - View Cloud Run logs');
      section.push('- `/gcp-scale` - Adjust auto-scaling settings\n');
    }

    if (profile.stack.cloud === 'aws') {
      section.push('### AWS Commands');
      section.push('- `/aws-deploy` - Deploy to AWS');
      section.push('- `/aws-logs` - View CloudWatch logs');
      section.push('- `/aws-scale` - Manage auto-scaling\n');
    }

    if (profile.special.compliance) {
      section.push('### Compliance Commands');
      section.push('- `/compliance-check` - Run compliance verification');
      section.push('- `/audit-report` - Generate audit report');
      section.push('- `/security-scan` - Run security scan\n');
    }

    if (profile.custom.tokenization) {
      section.push('### Tokenization Commands');
      section.push('- `/tokenize` - Tokenize real-world assets');
      section.push('- `/kyc-verify` - Verify KYC status');
      section.push('- `/transfer-check` - Validate transfer restrictions\n');
    }

    section.push('### Agent Commands');
    section.push('- `/agent <name>` - Activate specific agent');
    section.push('- `/workflow <name>` - Run multi-agent workflow');
    section.push('- `/agents-status` - View active agents');
    section.push('- `/agents-list` - List available agents\n');

    return section.join('\n');
  }

  /**
   * Helper to capitalize strings
   */
  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1).replace(/-/g, ' ');
  }

  /**
   * Format security requirement
   */
  formatSecurityRequirement(req) {
    const requirements = {
      'zero-trust': 'Zero-trust security model',
      'e2e-encryption': 'End-to-end encryption for all sensitive data',
      'mfa': 'Multi-factor authentication required',
      'secrets-management': 'Centralized secrets management system'
    };
    return requirements[req] || req;
  }

  /**
   * Check if file exists
   */
  async fileExists(filePath) {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
}

export default ClaudeConfigGenerator;