/**
 * Enhanced /initproject Command for Claude Code
 * With GitHub account detection and better documentation
 */

import { ProjectOrchestrator } from '../agents/project-orchestrator.js';
import { createWarmUpManager } from '../session/warmup.js';
import { registerProjectMCP } from './register-mcp.js';
import { createSubagentManager } from '../agents/subagent-manager.js';
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import fs from 'fs/promises';
import readline from 'readline';

const execAsync = promisify(exec);

export class InitProjectCommand {
  constructor() {
    this.orchestrator = new ProjectOrchestrator();
    this.name = 'initproject';
    this.description = 'Initialize current project with its own DevAssist';
  }

  async askQuestion(question) {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    return new Promise((resolve) => {
      rl.question(question, (answer) => {
        rl.close();
        resolve(answer);
      });
    });
  }

  async detectGitHubAccount(projectPath) {
    try {
      // Check git remote
      const { stdout } = await execAsync('git remote get-url origin', { cwd: projectPath });
      const url = stdout.trim();
      
      // Extract account from URL
      const match = url.match(/github\.com[:/]([^/]+)\//);
      if (match) {
        const detectedAccount = match[1];
        console.error(`\nüîç Detected GitHub account: ${detectedAccount}`);
        
        // Check if we have multiple accounts configured
        const accountsFile = path.join(process.env.HOME, '.config/claude/github_accounts.json');
        if (await fs.access(accountsFile).then(() => true).catch(() => false)) {
          const accounts = JSON.parse(await fs.readFile(accountsFile, 'utf8'));
          if (accounts.accounts && accounts.accounts.length > 1) {
            console.error('\nüìã Available GitHub accounts:');
            accounts.accounts.forEach((acc, i) => {
              console.error(`  ${i + 1}. ${acc.username} ${acc.username === detectedAccount ? '(detected)' : ''}`);
            });
            
            const choice = await this.askQuestion('\nWhich account to use? (number or username): ');
            
            if (/^\d+$/.test(choice)) {
              const idx = parseInt(choice) - 1;
              if (accounts.accounts[idx]) {
                return accounts.accounts[idx].username;
              }
            } else if (choice) {
              return choice;
            }
          }
        }
        
        return detectedAccount;
      }
    } catch (e) {
      console.error('‚ö†Ô∏è Could not detect GitHub account:', e.message);
    }
    
    // If can't detect, ask
    const account = await this.askQuestion('GitHub account name (or Enter to skip): ');
    return account || null;
  }

  async suggestDocumentation(analysis, projectPath) {
    const suggestions = [];
    
    console.error('\nüìö Documentation Analysis:');
    console.error('========================');
    
    // Always suggest README
    suggestions.push({
      type: 'README',
      reason: 'Essential project overview',
      priority: 'high',
      create: true
    });
    
    // Interactive documentation selection
    const wantArchitecture = await this.askQuestion('\nüìê Create ARCHITECTURE.md? (y/N): ');
    if (wantArchitecture.toLowerCase() === 'y') {
      suggestions.push({
        type: 'ARCHITECTURE',
        reason: 'System design and patterns',
        priority: 'high',
        create: true
      });
    }
    
    const wantAPI = await this.askQuestion('üîå Create API.md? (y/N): ');
    if (wantAPI.toLowerCase() === 'y') {
      suggestions.push({
        type: 'API',
        reason: 'API endpoints and usage',
        priority: 'high',
        create: true
      });
    }
    
    // Auto-suggest based on project
    if (analysis.hasTests) {
      suggestions.push({
        type: 'TESTING',
        reason: 'Test directory found',
        priority: 'medium',
        create: true
      });
    }
    
    return suggestions;
  }

  async setupTerminalRecording(projectPath) {
    const terminalLogDir = path.join(projectPath, '.devassist/terminal_logs');
    await fs.mkdir(terminalLogDir, { recursive: true });
    
    // Create terminal recording script
    const recordScript = `#!/bin/bash
# Terminal recording for DevAssist
LOG_FILE="${terminalLogDir}/session-$(date +%Y%m%d-%H%M%S).log"
echo "üìù Recording terminal to: $LOG_FILE"
script -q "$LOG_FILE" "$SHELL"
`;
    
    const scriptPath = path.join(projectPath, '.devassist/scripts/record-terminal.sh');
    await fs.writeFile(scriptPath, recordScript, { mode: 0o755 });
    
    console.error('‚úÖ Terminal recording configured');
    return scriptPath;
  }

  async execute(args = {}) {
    const projectPath = args.path || process.cwd();
    let projectName = path.basename(projectPath);
    
    // Get proper project name
    try {
      const packagePath = path.join(projectPath, 'package.json');
      if (await fs.access(packagePath).then(() => true).catch(() => false)) {
        const pkg = JSON.parse(await fs.readFile(packagePath, 'utf8'));
        if (pkg.name) projectName = pkg.name;
      }
    } catch {}
    
    const displayName = projectName.charAt(0).toUpperCase() + projectName.slice(1);
    
    console.error(`\nüöÄ Enhanced DevAssist Initialization`);
    console.error(`====================================`);
    console.error(`üìÅ Project: ${displayName}`);
    console.error(`üìÇ Path: ${projectPath}\n`);
    
    try {
      // Step 1: Detect GitHub Account
      console.error('Step 1: GitHub Configuration...');
      const githubAccount = await this.detectGitHubAccount(projectPath);
      if (githubAccount) {
        console.error(`‚úÖ Using GitHub account: ${githubAccount}`);
      }
      
      // Step 2: Create project structure
      console.error('\nStep 2: Creating project structure...');
      await this.createProjectStructure(projectPath);
      
      // Step 3: Setup terminal recording
      console.error('\nStep 3: Setting up terminal recording...');
      await this.setupTerminalRecording(projectPath);
      
      // Step 4: Analyze and suggest documentation
      console.error('\nStep 4: Documentation setup...');
      const analysis = await this.orchestrator.analyzeProject(projectPath);
      const docSuggestions = await this.suggestDocumentation(analysis, projectPath);
      
      // Step 5: Create documentation
      console.error('\nStep 5: Creating documentation...');
      await this.createDocumentation(projectPath, docSuggestions);
      
      // Step 6: Configure warmup
      console.error('\nStep 6: Configuring warmup...');
      await this.configureWarmup(projectPath, projectName);
      
      // Step 7: Initialize with orchestrator
      console.error('\nStep 7: Creating subagents...');
      const result = await this.orchestrator.initProject(projectPath, {
        documentation: docSuggestions,
        analysis: analysis,
        githubAccount: githubAccount
      });
      
      // Step 8: Create project MCP server
      console.error('\nStep 8: Creating project MCP server...');
      await this.createProjectMCPServer(projectPath, projectName);
      
      // Step 9: Setup subagents
      console.error('\nStep 9: Setting up project-specific agents...');
      const subagentResults = await this.createProjectSubagents(projectPath, projectName);
      
      // Step 10: Register with Claude Code
      console.error('\nStep 10: Registering with Claude Code...');
      await this.registerWithClaudeCode(projectName, projectPath);
      
      // Step 11: Disable generic DevAssist
      console.error('\nStep 11: Isolating project environment...');
      await this.disableGenericDevAssist(projectPath);
      
      // Generate final report
      const report = this.generateInitReport(
        displayName, 
        analysis, 
        result, 
        docSuggestions.filter(d => d.create),
        subagentResults,
        githubAccount
      );
      
      console.error(`\n‚úÖ ${displayName} DevAssist initialization complete!`);
      
      return {
        content: [{
          type: 'text',
          text: report
        }]
      };
      
    } catch (error) {
      console.error(`\n‚ùå Error during initialization: ${error.message}`);
      console.error(error.stack);
      return {
        content: [{
          type: 'text',
          text: `Error initializing project: ${error.message}\n\nPlease check the logs and try again.`
        }]
      };
    }
  }

  // ... rest of the methods remain the same ...
}

export default InitProjectCommand;
