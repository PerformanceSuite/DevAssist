#!/usr/bin/env node
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema, ListResourcesRequestSchema, ReadResourceRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import { execSync, exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);
import { existsSync, mkdirSync, readFileSync } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Import ENHANCED database functions with project isolation
import { initDatabases } from './src/database/init-enhanced.js';
import {
  recordDecision,
  trackProgress,
  getProjectMemory,
  semanticSearch,
  identifyDuplicates,
  addCodePattern,
  generateEmbedding
} from './src/database/dataAccess.js';

// Import ENHANCED documentation with self-awareness
import { 
  searchDocumentation,
  getSelfDocumentation,
  listDocumentation,
  formatDocumentationResults
} from './src/documentation/enhanced.js';

// Import SESSION management for continuity
import { getSessionManager } from './src/session/persistence.js';
import { createWarmUpManager } from './src/session/warmup.js';
import { createSessionStartupEnhancer } from './src/session/startup-enhancer.js';
import { createSessionHeartbeat } from './src/session/heartbeat.js';

// Import original documentation resources (keeping for compatibility)
import { 
  getDocumentationResources, 
  readDocumentationResource,
  hasDocumentation,
  getDocumentationPath
} from './src/resources/documentationResources.js';

// Import orchestration and command system
import { InitProjectCommand } from './src/commands/initproject.js';
import { ProjectOrchestrator } from './src/agents/project-orchestrator.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Global instances
let dbInitialized = false;
let databases = null;
let sessionManager = null;
let projectIsolation = null;
let warmUpManager = null;
let startupEnhancer = null;
let sessionHeartbeat = null;

// Enhanced initialization with project isolation
async function ensureDbInitialized() {
  if (!dbInitialized) {
    // Check if this project has its own DevAssist (no generic allowed)
    const projectPath = process.env.DEVASSIST_PROJECT_PATH || process.cwd();
    const noGenericPath = path.join(projectPath, '.devassist/.no-generic');
    
    if (existsSync(noGenericPath)) {
      console.error('This project uses its own DevAssist instance.');
      console.error('Generic DevAssist is disabled here.');
      process.exit(0);
    }
    
    // console.log('üöÄ Initializing DevAssist with enhanced features...');
    
    // Initialize with project isolation
    databases = await initDatabases();
    
    // Set up session manager
    sessionManager = getSessionManager(
      databases.projectName,
      databases.paths,
      databases.sqlite
    );
    
    // Set up warm-up manager
    warmUpManager = createWarmUpManager(
      databases.paths.projectPath,
      databases,
      sessionManager
    );
    
    // Set up startup enhancer for actionable session starts
    startupEnhancer = createSessionStartupEnhancer(
      sessionManager,
      databases,
      warmUpManager
    );
    
    // Set up session heartbeat for long sprints
    sessionHeartbeat = createSessionHeartbeat(sessionManager);
    
    // Store isolation validator
    projectIsolation = databases.isolation;
    
    dbInitialized = true;
    
    // console.log(`‚úÖ DevAssist ready for project: ${databases.projectName}`);
    // console.log(`üìÅ Data path: ${databases.dataPath}`);
  }
  
  return { databases, sessionManager, projectIsolation };
}

// Create server instance
const server = new Server({
  name: 'devassist-mcp',
  version: '2.2.0', // Updated version with all enhancements
}, {
  capabilities: {
    tools: {},
    resources: {},
  },
});

// Define development assistance tools with enhanced features
const tools = [
  {
    name: 'analyze_codebase',
    description: 'Analyze the current codebase structure and identify patterns',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to analyze (absolute or relative)',
          default: '.',
        },
        depth: {
          type: 'number',
          description: 'Directory depth to analyze',
          default: 3,
        },
        pattern: {
          type: 'string',
          description: 'File pattern to match (e.g., *.py, *.js)',
          default: '*',
        },
        index_patterns: {
          type: 'boolean',
          description: 'Index code patterns for duplicate detection',
          default: false,
        },
      },
    },
  },
  {
    name: 'record_architectural_decision',
    description: 'Record an architectural decision with context and reasoning',
    inputSchema: {
      type: 'object',
      properties: {
        decision: {
          type: 'string',
          description: 'The architectural decision made',
        },
        context: {
          type: 'string',
          description: 'Context and reasoning behind the decision',
        },
        alternatives: {
          type: 'array',
          items: { type: 'string' },
          description: 'Alternative approaches considered',
        },
        impact: {
          type: 'string',
          description: 'Expected impact on the system',
        },
        project: {
          type: 'string',
          description: 'Project name (for multi-project support)',
          default: 'default',
        },
      },
      required: ['decision', 'context'],
    },
  },
  {
    name: 'get_project_memory',
    description: 'Retrieve project memory using semantic search',
    inputSchema: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Search query for specific memories',
        },
        category: {
          type: 'string',
          description: 'Category to filter by',
          enum: ['decisions', 'progress', 'lessons', 'architecture', 'all'],
          default: 'all',
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results to return',
          default: 10,
        },
        project: {
          type: 'string',
          description: 'Project name to search within',
          default: 'default',
        },
      },
    },
  },
  {
    name: 'track_progress',
    description: 'Track progress on a specific feature or milestone',
    inputSchema: {
      type: 'object',
      properties: {
        milestone: {
          type: 'string',
          description: 'Name of the milestone or feature',
        },
        status: {
          type: 'string',
          description: 'Current status',
          enum: ['not_started', 'in_progress', 'testing', 'completed', 'blocked'],
        },
        notes: {
          type: 'string',
          description: 'Additional notes or context',
        },
        blockers: {
          type: 'array',
          items: { type: 'string' },
          description: 'List of blockers or issues',
        },
        project: {
          type: 'string',
          description: 'Project name',
          default: 'default',
        },
      },
      required: ['milestone', 'status'],
    },
  },
  {
    name: 'identify_duplicate_effort',
    description: 'Use semantic search to identify potential duplicate functionality',
    inputSchema: {
      type: 'object',
      properties: {
        feature: {
          type: 'string',
          description: 'Feature or functionality to check for duplicates',
        },
        path: {
          type: 'string',
          description: 'Path to analyze',
          default: '.',
        },
        similarity_threshold: {
          type: 'number',
          description: 'Similarity threshold (0.0 to 1.0)',
          default: 0.7,
        },
      },
      required: ['feature'],
    },
  },
  {
    name: 'semantic_search',
    description: 'Search across all project data using natural language',
    inputSchema: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Natural language search query',
        },
        search_type: {
          type: 'string',
          description: 'Type of data to search',
          enum: ['decisions', 'code_patterns', 'all'],
          default: 'all',
        },
        min_similarity: {
          type: 'number',
          description: 'Minimum similarity score (0.0 to 1.0)',
          default: 0.5,
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results',
          default: 10,
        },
        project: {
          type: 'string',
          description: 'Project to search within',
          default: null,
        },
      },
      required: ['query'],
    },
  },
  {
    name: 'get_documentation',
    description: 'Retrieve documentation for SuperCollider, Claude Code, or project-specific features',
    inputSchema: {
      type: 'object',
      properties: {
        topic: {
          type: 'string',
          description: 'Documentation topic to retrieve',
        },
        source: {
          type: 'string',
          description: 'Documentation source',
          enum: ['supercollider', 'claude_code', 'project', 'all'],
          default: 'all',
        },
        search_depth: {
          type: 'number',
          description: 'How deep to search for relevant content',
          default: 3,
        },
      },
      required: ['topic'],
    },
  },
  {
    name: 'analyze_dependencies',
    description: 'Analyze project dependencies and their relationships',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Project path to analyze',
          default: '.',
        },
        include_dev: {
          type: 'boolean',
          description: 'Include development dependencies',
          default: true,
        },
        check_updates: {
          type: 'boolean',
          description: 'Check for available updates',
          default: false,
        },
      },
    },
  },
  {
    name: 'generate_summary',
    description: 'Generate a summary of recent development activity and decisions',
    inputSchema: {
      type: 'object',
      properties: {
        days_back: {
          type: 'number',
          description: 'Number of days to look back',
          default: 7,
        },
        include_commits: {
          type: 'boolean',
          description: 'Include git commit history',
          default: true,
        },
        project: {
          type: 'string',
          description: 'Project to summarize',
          default: 'default',
        },
      },
    },
  },
  {
    name: 'start_session',
    description: 'Start a new development session with context loading',
    inputSchema: {
      type: 'object',
      properties: {
        description: {
          type: 'string',
          description: 'Session description',
          default: 'Development session',
        },
      },
    },
  },
  {
    name: 'end_session',
    description: 'End current session with knowledge preservation',
    inputSchema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'session_checkpoint',
    description: 'Save a checkpoint in the current session',
    inputSchema: {
      type: 'object',
      properties: {
        summary: {
          type: 'string',
          description: 'Checkpoint summary',
        },
      },
      required: ['summary'],
    },
  },
  {
    name: 'initproject',
    description: 'Initialize a new project with DevAssist - sets up GitHub integration, Claude configuration, and development environment',
    inputSchema: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Project path to initialize',
          default: '.',
        },
        skipDocumentation: {
          type: 'boolean',
          description: 'Skip documentation setup',
          default: false,
        },
        documentation: {
          type: 'array',
          items: { type: 'string' },
          description: 'Documentation types to create (README, ARCHITECTURE, API)',
          default: ['README', 'ARCHITECTURE', 'API'],
        },
      },
    },
  },
  {
    name: 'session-start',
    description: 'Start development session with warmup (slash command: /session-start)',
    inputSchema: {
      type: 'object',
      properties: {
        project: {
          type: 'string',
          description: 'Project name (optional, uses current project if not specified)',
        },
        description: {
          type: 'string',
          description: 'Session description',
          default: 'Development session',
        },
      },
    },
  },
  {
    name: 'session-end', 
    description: 'End development session with cleanup (slash command: /session-end)',
    inputSchema: {
      type: 'object',
      properties: {
        project: {
          type: 'string',
          description: 'Project name (optional, uses current project if not specified)',
        },
      },
    },
  },
  {
    name: 'session-status',
    description: 'Check session and warmup status (slash command: /session-status)',
    inputSchema: {
      type: 'object',
      properties: {
        project: {
          type: 'string',
          description: 'Project name (optional, uses current project if not specified)',
        },
      },
    },
  },
  {
    name: 'sprint-check',
    description: 'Quick sprint progress check to keep DevAssist engaged',
    inputSchema: {
      type: 'object',
      properties: {
        message: {
          type: 'string',
          description: 'Optional status update or note',
        },
      },
    },
  },
];

// Handle list tools request
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return { tools };
});

// Handle list resources request
server.setRequestHandler(ListResourcesRequestSchema, async () => {
  const resources = getDocumentationResources();
  return { resources };
});

// Handle read resource request
server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  const { uri } = request.params;
  
  try {
    const resource = readDocumentationResource(uri);
    return resource;
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: `Error reading resource: ${error.message}`,
        },
      ],
    };
  }
});

// Handle tool execution
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  await ensureDbInitialized();
  
  const { name, arguments: args } = request.params;
  
  try {
    // Apply project isolation to all queries
    const isolatedArgs = projectIsolation ? projectIsolation.validateQuery(args || {}) : args;
    
    switch (name) {
      case 'analyze_codebase': {
        const { path: codePath = '.', depth = 3, pattern = '*', index_patterns = false } = isolatedArgs || {};
        
        try {
          const fullPath = path.isAbsolute(codePath) ? codePath : path.resolve(codePath);
          const { execSync } = await import('child_process');
          
          // Get basic file count and structure
          const fileList = execSync(
            `find "${fullPath}" -maxdepth ${depth} -name "${pattern}" -type f 2>/dev/null | head -100`,
            { encoding: 'utf8', shell: '/bin/bash' }
          ).trim().split('\n').filter(Boolean);
          
          // Get language statistics if possible
          let languageStats = '';
          try {
            languageStats = execSync(
              `find "${fullPath}" -maxdepth ${depth} -type f -name "*.*" | sed 's/.*\\.//' | sort | uniq -c | sort -rn | head -10`,
              { encoding: 'utf8', shell: '/bin/bash' }
            ).trim();
          } catch (e) {
            // Ignore if command fails
          }
          
          // Index patterns if requested
          if (index_patterns && fileList.length > 0) {
            for (const file of fileList.slice(0, 20)) { // Limit to first 20 files
              try {
                const content = readFileSync(file, 'utf8').substring(0, 1000); // First 1000 chars
                const language = path.extname(file).substring(1);
                await addCodePattern(file, content, language, databases.projectName);
              } catch (e) {
                // Skip files that can't be read
              }
            }
          }
          
          return {
            content: [
              {
                type: 'text',
                text: `Codebase Analysis for ${fullPath}:
                
Files found: ${fileList.length}
Code files: ${fileList.filter(f => /\.(js|ts|py|java|cpp|c|rs|go)$/.test(f)).length}
Total lines of code: ${execSync(`find "${fullPath}" -name "${pattern}" -type f -exec wc -l {} + 2>/dev/null | tail -1 | awk '{print $1}'`, { encoding: 'utf8' }).trim() || '0'}

${languageStats ? `\nFile types breakdown:\n${languageStats}` : ''}

Sample files:
${fileList.slice(0, 10).map(f => `  - ${f.replace(fullPath, '.')}`).join('\n')}

${index_patterns ? '\n‚úì Code patterns indexed for duplicate detection' : ''}`,
              },
            ],
          };
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `Error analyzing codebase: ${error.message}`,
              },
            ],
          };
        }
      }

      case 'record_architectural_decision': {
        const { decision, context, alternatives, impact } = isolatedArgs || {};
        
        try {
          const result = await recordDecision(
            decision,
            context,
            alternatives,
            impact,
            databases.projectName
          );
          
          // Add to session if active
          if (sessionManager) {
            sessionManager.addDecision({
              decision,
              context,
              impact,
              alternatives
            });
          }
          
          return {
            content: [
              {
                type: 'text',
                text: `‚úì Architectural decision recorded successfully!

**Decision:** ${decision}
**Context:** ${context}
**Impact:** ${impact || 'Not specified'}
**Alternatives considered:** ${alternatives ? alternatives.join(', ') : 'None specified'}

This decision has been stored in the project knowledge base and will be available for future reference.`,
              },
            ],
          };
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `Error recording decision: ${error.message}`,
              },
            ],
          };
        }
      }

      case 'get_project_memory': {
        const { query, category = 'all', limit = 10 } = isolatedArgs || {};
        
        try {
          // Force current project
          const project = databases.projectName;
          const memories = await getProjectMemory(query, category, limit, project);
          
          if (!memories || memories.length === 0) {
            return {
              content: [
                {
                  type: 'text',
                  text: `No project memory found for category: ${category}

Try recording some decisions or progress updates first, or adjust your search query.`,
                },
              ],
            };
          }
          
          const formattedMemories = memories.map((m, i) => {
            if (m.decision) {
              return `üìã **Decision**: ${m.decision}
   Context: ${m.context}
   Impact: ${m.impact || 'Not specified'}
   Date: ${new Date(m.timestamp).toLocaleDateString()}`;
            } else if (m.milestone) {
              return `üìà **Progress**: ${m.milestone}
   Status: ${m.status}
   Notes: ${m.notes || 'None'}
   Updated: ${new Date(m.updated_at || m.created_at).toLocaleDateString()}`;
            }
            return `üìù **Memory**: ${JSON.stringify(m).substring(0, 200)}...`;
          }).join('\n\n');
          
          return {
            content: [
              {
                type: 'text',
                text: `üß† Project Memory (${memories.length} results):\n\n${formattedMemories}`,
              },
            ],
          };
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `Error retrieving project memory: ${error.message}`,
              },
            ],
          };
        }
      }

      case 'track_progress': {
        const { milestone, status, notes, blockers } = isolatedArgs || {};
        
        try {
          const result = await trackProgress(
            milestone,
            status,
            notes,
            blockers,
            databases.projectName
          );
          
          // Add to session if active
          if (sessionManager) {
            sessionManager.addKnowledge({
              type: 'progress',
              milestone,
              status,
              notes,
              blockers
            });
          }
          
          return {
            content: [
              {
                type: 'text',
                text: `‚úì Progress tracked successfully!

**Milestone:** ${milestone}
**Status:** ${status}
**Notes:** ${notes || 'None'}
**Blockers:** ${blockers && blockers.length > 0 ? blockers.join(', ') : 'None'}

Progress has been recorded in the project knowledge base.`,
              },
            ],
          };
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `Error tracking progress: ${error.message}`,
              },
            ],
          };
        }
      }

      case 'identify_duplicate_effort': {
        const { feature, path: searchPath = '.', similarity_threshold = 0.7 } = isolatedArgs || {};
        
        try {
          const result = await identifyDuplicates(
            feature,
            searchPath,
            similarity_threshold,
            databases.projectName
          );
          
          if (!result.duplicates || result.duplicates.length === 0) {
            return {
              content: [
                {
                  type: 'text',
                  text: `‚úì No duplicate effort detected for "${feature}"

This appears to be new functionality. Proceed with implementation!`,
                },
              ],
            };
          }
          
          // Format duplicates with similarity scores
          const formattedDuplicates = result.duplicates
            .slice(0, 10)
            .map((d, i) => `${i + 1}. **${d.file_path}** (${(d.similarity * 100).toFixed(1)}% similar)
   Language: ${d.language}
   Preview: ${d.content.substring(0, 100)}...`)
            .join('\n\n');
          
          return {
            content: [
              {
                type: 'text',
                text: `‚ö†Ô∏è Potential duplicate effort detected for "${feature}":

${result.message}

Top matches:
${formattedDuplicates}

Consider reviewing these existing implementations before creating new functionality.`,
              },
            ],
          };
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `Error detecting duplicates: ${error.message}`,
              },
            ],
          };
        }
      }

      case 'semantic_search': {
        const { query, search_type = 'all', min_similarity = 0.5, limit = 10 } = isolatedArgs || {};
        
        try {
          const project = databases.projectName;
          const results = [];
          
          if (search_type === 'all' || search_type === 'decisions') {
            const decisionResults = await semanticSearch(query, {
              table: 'decisions',
              project: project,
              limit: limit,
              threshold: min_similarity
            });
            results.push(...decisionResults.map(r => ({ ...r, type: 'decision' })));
          }
          
          if (search_type === 'all' || search_type === 'code_patterns') {
            const patternResults = await semanticSearch(query, {
              table: 'code_patterns',
              project: project,
              limit: limit,
              threshold: min_similarity
            });
            results.push(...patternResults.map(r => ({ ...r, type: 'code_pattern' })));
          }
          
          if (results.length === 0) {
            return {
              content: [
                {
                  type: 'text',
                  text: `No results found for query: "${query}"

Try adjusting your search terms or lowering the similarity threshold.`,
                },
              ],
            };
          }
          
          // Sort by similarity and format
          results.sort((a, b) => a._distance - b._distance);
          
          const formattedResults = results.slice(0, limit).map((r, i) => {
            const similarity = ((1 - r._distance) * 100).toFixed(1);
            if (r.type === 'decision') {
              return `${i + 1}. üìã **Decision** (${similarity}% match)
   ${r.text.substring(0, 200)}...`;
            } else {
              return `${i + 1}. üíª **Code Pattern** (${similarity}% match)
   File: ${r.file_path}
   ${r.content.substring(0, 100)}...`;
            }
          }).join('\n\n');
          
          return {
            content: [
              {
                type: 'text',
                text: `üîç Semantic Search Results for "${query}":

Found ${results.length} results above ${(min_similarity * 100).toFixed(0)}% similarity:

${formattedResults}`,
              },
            ],
          };
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `Error performing semantic search: ${error.message}`,
              },
            ],
          };
        }
      }

      case 'get_documentation': {
        const { topic, source = 'all', search_depth = 3 } = isolatedArgs || {};
        
        try {
          // Use enhanced documentation search
          const results = await searchDocumentation(topic, { 
            source, 
            limit: search_depth 
          });
          
          // If no results and asking about DevAssist, return self-documentation
          if (results.length === 0 && topic.toLowerCase().includes('devassist')) {
            const selfDoc = await getSelfDocumentation();
            return {
              content: [{
                type: 'text',
                text: selfDoc.content
              }]
            };
          }
          
          // Format and return results
          const formatted = formatDocumentationResults(results);
          
          return {
            content: [{
              type: 'text',
              text: formatted
            }]
          };
        } catch (error) {
          // Fallback to basic response
          return {
            content: [
              {
                type: 'text',
                text: `üìö Documentation search for "${topic}":

Error searching documentation: ${error.message}

Try these alternative searches:
- "DevAssist tools" - List of available tools
- "DevAssist configuration" - Setup guide
- "DevAssist sessions" - Session management
- Use listDocumentation() to see available docs`,
              },
            ],
          };
        }
      }

      case 'analyze_dependencies': {
        const { path: projectPath = '.', include_dev = true, check_updates = false } = isolatedArgs || {};
        
        try {
          const fullPath = path.isAbsolute(projectPath) ? projectPath : path.resolve(projectPath);
          
          // Check for package.json
          const packageJsonPath = path.join(fullPath, 'package.json');
          if (existsSync(packageJsonPath)) {
            const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
            const deps = packageJson.dependencies || {};
            const devDeps = include_dev ? (packageJson.devDependencies || {}) : {};
            
            return {
              content: [
                {
                  type: 'text',
                  text: `üì¶ Dependency Analysis for ${fullPath}:

Production Dependencies: ${Object.keys(deps).length}
${Object.entries(deps).map(([name, version]) => `  - ${name}: ${version}`).join('\n')}

${include_dev ? `Development Dependencies: ${Object.keys(devDeps).length}
${Object.entries(devDeps).map(([name, version]) => `  - ${name}: ${version}`).join('\n')}` : ''}

Total: ${Object.keys(deps).length + Object.keys(devDeps).length} dependencies`,
                },
              ],
            };
          }
          
          return {
            content: [
              {
                type: 'text',
                text: `No package.json found in ${fullPath}`,
              },
            ],
          };
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `Error analyzing dependencies: ${error.message}`,
              },
            ],
          };
        }
      }

      case 'generate_summary': {
        const { days_back = 7, include_commits = true } = isolatedArgs || {};
        
        try {
          const project = databases.projectName;
          
          // Get recent decisions
          const recentDecisions = await getProjectMemory(null, 'decisions', 20, project);
          const recentProgress = await getProjectMemory(null, 'progress', 20, project);
          
          // Filter by date
          const cutoffDate = new Date();
          cutoffDate.setDate(cutoffDate.getDate() - days_back);
          
          const filteredDecisions = recentDecisions.filter(d => 
            new Date(d.timestamp) > cutoffDate
          );
          
          const filteredProgress = recentProgress.filter(p => 
            new Date(p.updated_at || p.created_at) > cutoffDate
          );
          
          let commitSummary = '';
          if (include_commits) {
            try {
              const gitLog = execSync(`git log --since="${days_back} days ago" --oneline --no-merges 2>/dev/null | head -20`, {
                encoding: 'utf8',
              }).trim();
              
              if (gitLog) {
                const commitCount = gitLog.split('\n').length;
                commitSummary = `

üìù Git Activity:
- Commits: ${commitCount}
Recent commits:
${gitLog.split('\n').slice(0, 5).map(c => `  ${c}`).join('\n')}`;
              }
            } catch (e) {
              // No git repo or error
            }
          }
          
          // Get session status
          const sessionStatus = sessionManager ? sessionManager.getStatus() : null;
          const sessionInfo = sessionStatus && sessionStatus.active ? 
            `\nüîÑ Active Session: ${sessionStatus.session}\n   Knowledge items: ${sessionStatus.knowledge}` : '';
          
          return {
            content: [
              {
                type: 'text',
                text: `üìä Development Summary (Last ${days_back} days):

üéØ Project: ${project}

üìã Architectural Decisions: ${filteredDecisions.length}
${filteredDecisions.slice(0, 3).map(d => `  - ${d.decision}`).join('\n')}

üìà Progress Updates: ${filteredProgress.length}
${filteredProgress.slice(0, 3).map(p => `  - ${p.milestone}: ${p.status}`).join('\n')}
${commitSummary}
${sessionInfo}

Use get_project_memory for detailed information on any item.`,
              },
            ],
          };
        } catch (error) {
          return {
            content: [
              {
                type: 'text',
                text: `Error generating summary: ${error.message}`,
              },
            ],
          };
        }
      }

      case 'start_session': {
        const { description = 'Development session' } = isolatedArgs || {};
        
        try {
          // Run project-specific warmup if it exists
          const projectPath = databases.paths.projectPath || process.cwd();
          const warmupScriptPath = path.join(projectPath, '.devassist/warmup.sh');
          const warmupJsPath = path.join(projectPath, '.devassist/warmup/warmup.js');
          
          if (existsSync(warmupScriptPath)) {
            console.error('[START_SESSION] Running project warmup script...');
            try {
              await execAsync(`bash "${warmupScriptPath}"`, { cwd: projectPath });
            } catch (warmupError) {
              console.error('[START_SESSION] Warmup script error:', warmupError.message);
            }
          } else if (existsSync(warmupJsPath)) {
            console.error('[START_SESSION] Running project warmup...');
            try {
              await execAsync(`node "${warmupJsPath}"`, { cwd: projectPath });
            } catch (warmupError) {
              console.error('[START_SESSION] Warmup error:', warmupError.message);
            }
          }
          
          // Use the enhanced startup that includes warm-up and sprint status
          // console.log('üî• Starting enhanced session with warm-up and sprint status...');
          const enhancedResult = await startupEnhancer.startEnhancedSession(description);
          
          // Return the actionable report, not open-ended questions
          return enhancedResult;
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `Error starting session: ${error.message}`
            }]
          };
        }
      }

      case 'end_session': {
        try {
          // First run the cleanup agent if it exists
          const projectPath = databases.paths.projectPath || process.cwd();
          const cleanupAgentPath = path.join(projectPath, '.devassist/agents/cleanup.js');
          
          if (existsSync(cleanupAgentPath)) {
            console.error('[END_SESSION] Running cleanup agent...');
            try {
              await execAsync(`node "${cleanupAgentPath}"`, { cwd: projectPath });
            } catch (cleanupError) {
              console.error('[END_SESSION] Cleanup agent error:', cleanupError.message);
            }
          }
          
          // Then run the normal session end
          const summary = await sessionManager.endSession();
          
          // Also run the session-end hook if it exists
          const hookPath = path.join(projectPath, '.devassist/session-end-hook.js');
          if (existsSync(hookPath)) {
            try {
              await execAsync(`node "${hookPath}"`, { cwd: projectPath });
            } catch (hookError) {
              console.error('[END_SESSION] Hook error:', hookError.message);
            }
          }
          
          return {
            content: [{
              type: 'text',
              text: `üèÅ Session Ended Successfully!

${summary}

‚úÖ Knowledge preserved for next session
‚úÖ Terminal logs saved
‚úÖ Cleanup agent executed
‚úÖ Context ready for continuity

Start a new session anytime with start_session.`
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `Error ending session: ${error.message}`
            }]
          };
        }
      }

      case 'session_checkpoint': {
        const { summary } = isolatedArgs || {};
        
        try {
          const checkpoint = await sessionManager.checkpoint(summary);
          
          return {
            content: [{
              type: 'text',
              text: `üíæ Checkpoint Saved!

Time: ${checkpoint.timestamp}
Summary: ${checkpoint.summary}
Knowledge items: ${checkpoint.knowledge_count}
Decisions: ${checkpoint.decisions_count}

Continue working - session is still active.`
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `Error creating checkpoint: ${error.message}`
            }]
          };
        }
      }
      
      case 'session-start': {
        // This is the slash command version that works like /initproject
        const { project, description = 'Development session' } = isolatedArgs || {};
        
        try {
          // If project specified, switch to it
          if (project) {
            const projectPath = path.join(process.env.PROJECT_ROOT || '/Users/danielconnolly/Projects', project);
            process.env.DEVASSIST_PROJECT = project;
            process.env.DEVASSIST_PROJECT_PATH = projectPath;
            
            // Re-initialize databases for the new project
            databases = await initDatabases();
            sessionManager = getSessionManager(
              databases.projectName,
              databases.paths,
              databases.sqlite
            );
            warmUpManager = createWarmUpManager(
              databases.paths.projectPath,
              databases,
              sessionManager
            );
            startupEnhancer = createSessionStartupEnhancer(
              sessionManager,
              databases,
              warmUpManager
            );
          }
          
          // Run the same logic as start_session
          const projectPath = databases.paths.projectPath || process.cwd();
          const warmupScriptPath = path.join(projectPath, '.devassist/warmup.sh');
          const warmupJsPath = path.join(projectPath, '.devassist/warmup.js');
          
          if (existsSync(warmupScriptPath)) {
            console.error('[/SESSION-START] Running project warmup script...');
            try {
              await execAsync(`bash "${warmupScriptPath}"`, { cwd: projectPath });
            } catch (warmupError) {
              console.error('[/SESSION-START] Warmup script error:', warmupError.message);
            }
          } else if (existsSync(warmupJsPath)) {
            console.error('[/SESSION-START] Running project warmup...');
            try {
              await execAsync(`node "${warmupJsPath}"`, { cwd: projectPath });
            } catch (warmupError) {
              console.error('[/SESSION-START] Warmup error:', warmupError.message);
            }
          }
          
          // Use the enhanced startup that includes warm-up
          console.error('üî• Starting enhanced session with warm-up...');
          const enhancedResult = await startupEnhancer.startEnhancedSession(description);
          
          // Start heartbeat for long sprints
          if (sessionHeartbeat) {
            sessionHeartbeat.start();
            console.error('üíì Session heartbeat activated for long sprints');
          }
          
          return enhancedResult;
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `Error starting session: ${error.message}`
            }]
          };
        }
      }

      case 'session-end': {
        // This is the slash command version
        const { project } = isolatedArgs || {};
        
        try {
          if (project) {
            process.env.DEVASSIST_PROJECT = project;
          }
          
          // Run cleanup agent if it exists
          const projectPath = databases.paths.projectPath || process.cwd();
          const cleanupAgentPath = path.join(projectPath, '.devassist/agents/cleanup.js');
          
          if (existsSync(cleanupAgentPath)) {
            console.error('[/SESSION-END] üßπ Running cleanup agent...');
            try {
              await execAsync(`node "${cleanupAgentPath}"`, { cwd: projectPath });
            } catch (cleanupError) {
              console.error('[/SESSION-END] Cleanup agent error:', cleanupError.message);
            }
          }
          
          // Stop heartbeat
          if (sessionHeartbeat) {
            sessionHeartbeat.stop();
          }
          
          // Run the normal session end
          const summary = await sessionManager.endSession();
          
          // Also run the session-end hook if it exists
          const hookPath = path.join(projectPath, '.devassist/session-end-hook.js');
          if (existsSync(hookPath)) {
            try {
              await execAsync(`node "${hookPath}"`, { cwd: projectPath });
            } catch (hookError) {
              console.error('[/SESSION-END] Hook error:', hookError.message);
            }
          }
          
          return {
            content: [{
              type: 'text',
              text: `üèÅ Session Ended Successfully!

${summary}

‚úÖ Knowledge preserved for next session
‚úÖ Terminal logs saved
‚úÖ Cleanup agent executed
‚úÖ Context ready for continuity

Start a new session anytime with /session-start.`
            }]
          };
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `Error ending session: ${error.message}`
            }]
          };
        }
      }

      case 'session-status': {
        const { project } = isolatedArgs || {};
        
        if (project) {
          process.env.DEVASSIST_PROJECT = project;
        }
        
        const status = sessionManager ? sessionManager.getStatus() : null;
        const projectName = databases.projectName;
        
        if (!status || !status.active) {
          return {
            content: [{
              type: 'text', 
              text: `üìä No active session for project: ${projectName}

Use /session-start to begin a new session with warmup.`
            }]
          };
        }
        
        return {
          content: [{
            type: 'text',
            text: `üìä Session Status for ${projectName}:

üü¢ Active Session: ${status.session}
üìù Knowledge items: ${status.knowledge}
üéØ Decisions made: ${status.decisions || 0}
‚è±Ô∏è Duration: ${status.duration || 'Unknown'}

Warmup status: ${warmUpManager ? '‚úÖ Ready' : '‚ö†Ô∏è Not initialized'}
Cleanup agent: ${existsSync(path.join(databases.paths.projectPath, '.devassist/agents/cleanup.js')) ? '‚úÖ Available' : '‚ùå Not found'}`
          }]
        };
      }

      case 'sprint-check': {
        const { message } = isolatedArgs || {};
        
        // Record activity to keep DevAssist engaged
        if (sessionHeartbeat) {
          sessionHeartbeat.recordActivity();
        }
        
        // Get current sprint status
        const projectPath = databases.paths.projectPath || process.cwd();
        let sprintStatus = '';
        
        try {
          // Check for sprint file
          const sprintFiles = ['SPRINT_BLOCKCHAIN_INTEGRATION.md', 'SPRINT.md', 'TODO.md'];
          for (const file of sprintFiles) {
            const filePath = path.join(projectPath, file);
            if (existsSync(filePath)) {
              const content = readFileSync(filePath, 'utf8');
              const lines = content.split('\n');
              const completed = lines.filter(l => l.includes('‚úÖ')).length;
              const total = lines.filter(l => l.match(/^\d+\./)).length;
              
              if (total > 0) {
                sprintStatus = `Sprint Progress: ${completed}/${total} tasks (${Math.round(completed/total * 100)}%)`;
                break;
              }
            }
          }
        } catch {}
        
        // Check git status
        let gitStatus = '';
        try {
          const { stdout } = await execAsync('git status --porcelain', { cwd: projectPath });
          const changes = stdout.split('\n').filter(l => l.trim()).length;
          gitStatus = `Git: ${changes} uncommitted changes`;
        } catch {}
        
        // Add to session if message provided
        if (message && sessionManager) {
          sessionManager.addKnowledge({
            type: 'sprint-check',
            message: message,
            timestamp: new Date().toISOString()
          });
        }
        
        return {
          content: [{
            type: 'text',
            text: `üíì DevAssist Active!

${sprintStatus || 'No sprint file found'}
${gitStatus}
${message ? `\nüìù Note recorded: ${message}` : ''}

Session is warm and context maintained.
Use /sprint-check periodically during long sessions to keep DevAssist engaged.`
          }]
        };
      }

      case 'initproject': {
        // Auto-detect project from current directory
        const projectPath = process.cwd();
        
        try {
          // Create and execute the enhanced InitProject command
          const initCommand = new InitProjectCommand();
          const result = await initCommand.execute({ path: projectPath });
          
          // Return the result directly (it now includes the full report)
          return result;
        } catch (error) {
          return {
            content: [{
              type: 'text',
              text: `Error initializing project: ${error.message}`
            }]
          };
        }
      }

      default:
        return {
          content: [
            {
              type: 'text',
              text: `Unknown tool: ${name}`,
            },
          ],
        };
    }
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: `Error executing tool ${name}: ${error.message}`,
        },
      ],
    };
  }
});

// Start the server
const transport = new StdioServerTransport();
server.connect(transport);

console.error('üöÄ DevAssist MCP Server v2.2.0 - Enhanced Edition');
console.error('‚úÖ Features: Project Isolation | Session Management | Self-Documentation');
console.error(`üìÅ Project: ${process.env.DEVASSIST_PROJECT || 'default'}`);
console.error(`üìÇ Data Path: ${process.env.DEVASSIST_DATA_PATH || '.devassist/data'}`);

if (hasDocumentation()) {
  console.error('üìö Documentation available from:', getDocumentationPath());
}
